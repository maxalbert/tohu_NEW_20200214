{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contents TODO: Add a brief overview of the project here. Documentation: Tutorials (Start Here) How-To Guides Discussions Reference Guides Technical reference: API Reference Architectural Decision Records Changelog This documentation structure is based on Daniele Procida's excellent article on the Divio blog.","title":"Contents"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 Added \u00b6 Added primitive generators: Constant , Integer , HashDigest . Changed \u00b6 Fixed \u00b6 Removed \u00b6 0.1.0 \u00b6 Added \u00b6 Initial project skeleton.","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"Unreleased"},{"location":"CHANGELOG/#added","text":"Added primitive generators: Constant , Integer , HashDigest .","title":"Added"},{"location":"CHANGELOG/#changed","text":"","title":"Changed"},{"location":"CHANGELOG/#fixed","text":"","title":"Fixed"},{"location":"CHANGELOG/#removed","text":"","title":"Removed"},{"location":"CHANGELOG/#010","text":"","title":"0.1.0"},{"location":"CHANGELOG/#added_1","text":"Initial project skeleton.","title":"Added"},{"location":"attributions/","text":"Attributions The tohu logo is \"Chaos\" , created by Anna Sophie from the Noun Project (licensed under CC BY 3.0 )","title":"Attributions"},{"location":"ADRs/","text":"What are ADRs? Architectural Decision Records (ADR's) provide a lightweight format for documenting the reasons why certain architectural or technical decisions were taken, and more importantly the context which led to these decisions. This allows to revisit these decisions later on, in case the context changes or more information becomes available. See Michael Nygard's blog post for more details on ADR's. Despite the name \"architectural decision records\", where appropriate it is also encouraged to document technological decisions (for example which Javascript framework to use for a web frontend) or \"cultural\" decisions. ADR's should be placed in sepearate files that are numbered sequentially (e.g. 0001-some-useful-description.md ). The contents should follow this template : Title: short present tense imperative phrase, less than 50 characters, like a git commit message. Date: when was this issue discussed (to give approximate temporal context) Status: proposed, accepted, rejected, deprecated, superseded, etc. Context: what is the issue that we're seeing that is motivating this decision or change. This section describes the forces at play, including technological, political, social, and project local. These forces are probably in tension, and should be called out as such. The language in this section is value-neutral. It is simply describing facts. Decision: what is the change that we're actually proposing or doing (describes our response to these forces) Consequences: what becomes easier or more difficult to do because of this change. All consequences should be listed here, not just the \"positive\" ones. A particular decision may have positive, negative, and neutral consequences, but all of them affect the team and project in the future.","title":"What are ADRs?"},{"location":"discussions/","text":"Introduction This section contains discussions . A discussion: is understanding-oriented explains provides background and context (See here for context and more information.)","title":"Introduction"},{"location":"discussions/how_is_this_different_from_xyz/","text":"How is tohu different from XYZ? TODO: Write me!","title":"How is tohu different from XYZ?"},{"location":"how_to_guides/","text":"Introduction This section contains how-to guides . A how-to guide: is goal-oriented shows how to solve a specific problem is a series of steps (See here for context and more information.)","title":"Introduction"},{"location":"how_to_guides/installation/","text":"Installing tohu You can install the latest release by running: $ pip install -U tohu You can also grab the latest development version directly from GitHub: $ pip install git+https://github.com/maxalbert/tohu","title":"Installing tohu"},{"location":"how_to_guides/running_the_tests/","text":"Running the tests $ poetry run pytest Example output: ============================= test session starts ============================== platform linux -- Python 3.8.1, pytest-3.10.1, py-1.8.0, pluggy-0.13.0 rootdir: /path/to/code/tohu, inifile: collected 1 item tests/test_tohu.py . [100%] =========================== 1 passed in 0.11 seconds ===========================","title":"Running the tests"},{"location":"how_to_guides/setting_up_dev_environment/","text":"Setting up a development environment tohu uses poetry for dependency management, so make sure you have it installed . Next, install the necessary dependencies for tohu . We specify the --extras options to install the complete set of packages for a full development environment. $ poetry install --extras \"develop testing docs deploy\"","title":"Setting up a development environment"},{"location":"reference_guides/","text":"Introduction This section contains reference guides . A reference guide: is information-oriented describes the machinery is accurate and complete (See here for context and more information.)","title":"Introduction"},{"location":"reference_guides/derived_generators/","text":"Derived Generators Apply \u00b6 The Apply generator takes a function f as its first argument and a number of other tohu generators as its subsequent arguments. The items it produces are calculated by applying f to the items produced by the remaining generators. from tohu import Integer , Apply from tohu.utils import print_generated_sequence x_gen = Integer ( 10 , 99 ) y_gen = Integer ( 10 , 99 ) def f ( x , y ): return 100 * x + y c = Apply ( f , x_gen , y_gen ) x_gen . reset ( seed = 11111 ) y_gen . reset ( seed = 22222 ) c . reset ( seed = 33333 ) print_generated_sequence ( x_gen , num = 10 , fmt = ' {:<4d} ' , sep = ' ' ) print_generated_sequence ( y_gen , num = 10 , fmt = ' {:4d} ' , sep = ' ' ) print_generated_sequence ( c , num = 10 , sep = ' ' ) Generated sequence: 52 13 55 56 96 61 24 75 91 31 Generated sequence: 43 93 48 72 86 61 33 88 62 33 Generated sequence: 5243 1393 5548 5672 9686 6161 2433 7588 9162 3133 TODO: Explain why resetting c basically has no effect here and that the constituent generators of an Apply generator are not automatically reset when the latter is reset (rather, this needs to happen externally). Also explain the reasoning behind this.","title":"Derived generators"},{"location":"reference_guides/derived_generators/#apply","text":"The Apply generator takes a function f as its first argument and a number of other tohu generators as its subsequent arguments. The items it produces are calculated by applying f to the items produced by the remaining generators. from tohu import Integer , Apply from tohu.utils import print_generated_sequence x_gen = Integer ( 10 , 99 ) y_gen = Integer ( 10 , 99 ) def f ( x , y ): return 100 * x + y c = Apply ( f , x_gen , y_gen ) x_gen . reset ( seed = 11111 ) y_gen . reset ( seed = 22222 ) c . reset ( seed = 33333 ) print_generated_sequence ( x_gen , num = 10 , fmt = ' {:<4d} ' , sep = ' ' ) print_generated_sequence ( y_gen , num = 10 , fmt = ' {:4d} ' , sep = ' ' ) print_generated_sequence ( c , num = 10 , sep = ' ' ) Generated sequence: 52 13 55 56 96 61 24 75 91 31 Generated sequence: 43 93 48 72 86 61 33 88 62 33 Generated sequence: 5243 1393 5548 5672 9686 6161 2433 7588 9162 3133 TODO: Explain why resetting c basically has no effect here and that the constituent generators of an Apply generator are not automatically reset when the latter is reset (rather, this needs to happen externally). Also explain the reasoning behind this.","title":"Apply"},{"location":"reference_guides/item_list/","text":"ItemList Exporting an ItemList to various formats to_df() head() Specifying which columns to export, and in which order Custom field names Accessing nested field values Let's first create an ItemList instance, which we use in the rest of this section. from tohu.tohu_items_class import make_tohu_items_class from tohu.item_list import ItemList Quux = make_tohu_items_class ( \"Quux\" , field_names = [ \"aa\" , \"bb\" , \"cc\" , \"dd\" ]) items = [ Quux ( aa = 30 , bb = '672EF2' , cc = 'Johnny' , dd = False ), Quux ( aa = 32 , bb = '250204' , cc = 'David' , dd = True ), Quux ( aa = 55 , bb = '679DAE' , cc = 'Angela' , dd = False ), Quux ( aa = 43 , bb = '91554C' , cc = 'Pamela' , dd = True ), Quux ( aa = 56 , bb = '8EA713' , cc = 'Blake' , dd = True ), ] item_list = ItemList ( items , Quux ) item_list <ItemList containing 5 items> Exporting an ItemList to various formats \u00b6 to_df() \u00b6 When calling .to_df() without any arguments, all fields from all items will be exported. item_list . to_df () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } aa bb cc dd 0 30 672EF2 Johnny False 1 32 250204 David True 2 55 679DAE Angela False 3 43 91554C Pamela True 4 56 8EA713 Blake True head() \u00b6 There is also a .head() method, which is analogous to the one for pandas dataframes. item_list . head ( 3 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } aa bb cc dd 0 30 672EF2 Johnny False 1 32 250204 David True 2 55 679DAE Angela False Specifying which columns to export, and in which order \u00b6 We can export only a subset of columns, and/or rearrange their order, by specifying a list of field names. In this example we export only the three columns cc , aa , dd (in this order) instead of the full set of columns aa , bb , cc , dd . item_list . to_df ( fields = [ \"cc\" , \"aa\" , \"dd\" ]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cc aa dd 0 Johnny 30 False 1 David 32 True 2 Angela 55 False 3 Pamela 43 True 4 Blake 56 True Custom field names \u00b6 If we want to rename the columns we can pass a dictionary of the form {<new_column_name>: <existing_field_name>} , for example: item_list . to_df ( fields = { \"First Name\" : \"cc\" , \"Age\" : \"aa\" }) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } First Name Age 0 Johnny 30 1 David 32 2 Angela 55 3 Pamela 43 4 Blake 56 Accessing nested field values \u00b6 Let's create a second ItemList instance which contains nested items. Foo = make_tohu_items_class ( \"Foo\" , field_names = [ \"xx\" , \"yy\" ]) Bar = make_tohu_items_class ( \"Bar\" , field_names = [ \"rr\" , \"ss\" ]) items_2 = [ Quux ( aa = 30 , bb = Foo ( xx = '672EF2' , yy = Bar ( rr = 153 , ss = \"Engineer\" )), cc = 'Johnny' , dd = False ), Quux ( aa = 32 , bb = Foo ( xx = '250204' , yy = Bar ( rr = 193 , ss = \"Therapist\" )), cc = 'David' , dd = True ), Quux ( aa = 55 , bb = Foo ( xx = '679DAE' , yy = Bar ( rr = 101 , ss = \"Author\" )), cc = 'Angela' , dd = False ), Quux ( aa = 43 , bb = Foo ( xx = '91554C' , yy = Bar ( rr = 138 , ss = \"Scientist\" )), cc = 'Pamela' , dd = True ), Quux ( aa = 56 , bb = Foo ( xx = '8EA713' , yy = Bar ( rr = 147 , ss = \"Consultant\" )), cc = 'Blake' , dd = True ), ] item_list_2 = ItemList ( items_2 , Quux ) If we simply call to_df() without specifying the fields argument, the cells in column bb will contain the full nested values of the items of type Foo . item_list_2 . to_df () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } aa bb cc dd 0 30 Foo(xx='672EF2', yy=Bar(rr=153, ss='Engineer')) Johnny False 1 32 Foo(xx='250204', yy=Bar(rr=193, ss='Therapist')) David True 2 55 Foo(xx='679DAE', yy=Bar(rr=101, ss='Author')) Angela False 3 43 Foo(xx='91554C', yy=Bar(rr=138, ss='Scientist')) Pamela True 4 56 Foo(xx='8EA713', yy=Bar(rr=147, ss='Consultant')) Blake True If we are only interested in some of the individual values in the nested items Foo or Bar , it is possible to \"reach into\" them and extract those values by using the usual . notation for accessing attributes. fields = { \"Name\" : \"cc\" , \"ID\" : \"bb.xx\" , \"Job description\" : \"bb.yy.ss\" } item_list_2 . to_df ( fields = fields ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name ID Job description 0 Johnny 672EF2 Engineer 1 David 250204 Therapist 2 Angela 679DAE Author 3 Pamela 91554C Scientist 4 Blake 8EA713 Consultant Let's verify that an error is raised if an attribute name specified in the fields argument doesn't exist at any level. import pytest with pytest . raises ( AttributeError , match = \"Quux' object has no attribute 'bbb'\" ): item_list_2 . to_df ( fields = { \"Job description\" : \"bbb.yy.ss\" }) with pytest . raises ( AttributeError , match = \"Foo' object has no attribute 'yyy'\" ): item_list_2 . to_df ( fields = { \"Job description\" : \"bb.yyy.ss\" }) with pytest . raises ( AttributeError , match = \"Bar' object has no attribute 'sss'\" ): item_list_2 . to_df ( fields = { \"Job description\" : \"bb.yy.sss\" })","title":"Item list"},{"location":"reference_guides/item_list/#exporting-an-itemlist-to-various-formats","text":"","title":"Exporting an ItemList to various formats"},{"location":"reference_guides/item_list/#to_df","text":"When calling .to_df() without any arguments, all fields from all items will be exported. item_list . to_df () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } aa bb cc dd 0 30 672EF2 Johnny False 1 32 250204 David True 2 55 679DAE Angela False 3 43 91554C Pamela True 4 56 8EA713 Blake True","title":"to_df()"},{"location":"reference_guides/item_list/#head","text":"There is also a .head() method, which is analogous to the one for pandas dataframes. item_list . head ( 3 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } aa bb cc dd 0 30 672EF2 Johnny False 1 32 250204 David True 2 55 679DAE Angela False","title":"head()"},{"location":"reference_guides/item_list/#specifying-which-columns-to-export-and-in-which-order","text":"We can export only a subset of columns, and/or rearrange their order, by specifying a list of field names. In this example we export only the three columns cc , aa , dd (in this order) instead of the full set of columns aa , bb , cc , dd . item_list . to_df ( fields = [ \"cc\" , \"aa\" , \"dd\" ]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cc aa dd 0 Johnny 30 False 1 David 32 True 2 Angela 55 False 3 Pamela 43 True 4 Blake 56 True","title":"Specifying which columns to export, and in which order"},{"location":"reference_guides/item_list/#custom-field-names","text":"If we want to rename the columns we can pass a dictionary of the form {<new_column_name>: <existing_field_name>} , for example: item_list . to_df ( fields = { \"First Name\" : \"cc\" , \"Age\" : \"aa\" }) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } First Name Age 0 Johnny 30 1 David 32 2 Angela 55 3 Pamela 43 4 Blake 56","title":"Custom field names"},{"location":"reference_guides/item_list/#accessing-nested-field-values","text":"Let's create a second ItemList instance which contains nested items. Foo = make_tohu_items_class ( \"Foo\" , field_names = [ \"xx\" , \"yy\" ]) Bar = make_tohu_items_class ( \"Bar\" , field_names = [ \"rr\" , \"ss\" ]) items_2 = [ Quux ( aa = 30 , bb = Foo ( xx = '672EF2' , yy = Bar ( rr = 153 , ss = \"Engineer\" )), cc = 'Johnny' , dd = False ), Quux ( aa = 32 , bb = Foo ( xx = '250204' , yy = Bar ( rr = 193 , ss = \"Therapist\" )), cc = 'David' , dd = True ), Quux ( aa = 55 , bb = Foo ( xx = '679DAE' , yy = Bar ( rr = 101 , ss = \"Author\" )), cc = 'Angela' , dd = False ), Quux ( aa = 43 , bb = Foo ( xx = '91554C' , yy = Bar ( rr = 138 , ss = \"Scientist\" )), cc = 'Pamela' , dd = True ), Quux ( aa = 56 , bb = Foo ( xx = '8EA713' , yy = Bar ( rr = 147 , ss = \"Consultant\" )), cc = 'Blake' , dd = True ), ] item_list_2 = ItemList ( items_2 , Quux ) If we simply call to_df() without specifying the fields argument, the cells in column bb will contain the full nested values of the items of type Foo . item_list_2 . to_df () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } aa bb cc dd 0 30 Foo(xx='672EF2', yy=Bar(rr=153, ss='Engineer')) Johnny False 1 32 Foo(xx='250204', yy=Bar(rr=193, ss='Therapist')) David True 2 55 Foo(xx='679DAE', yy=Bar(rr=101, ss='Author')) Angela False 3 43 Foo(xx='91554C', yy=Bar(rr=138, ss='Scientist')) Pamela True 4 56 Foo(xx='8EA713', yy=Bar(rr=147, ss='Consultant')) Blake True If we are only interested in some of the individual values in the nested items Foo or Bar , it is possible to \"reach into\" them and extract those values by using the usual . notation for accessing attributes. fields = { \"Name\" : \"cc\" , \"ID\" : \"bb.xx\" , \"Job description\" : \"bb.yy.ss\" } item_list_2 . to_df ( fields = fields ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name ID Job description 0 Johnny 672EF2 Engineer 1 David 250204 Therapist 2 Angela 679DAE Author 3 Pamela 91554C Scientist 4 Blake 8EA713 Consultant Let's verify that an error is raised if an attribute name specified in the fields argument doesn't exist at any level. import pytest with pytest . raises ( AttributeError , match = \"Quux' object has no attribute 'bbb'\" ): item_list_2 . to_df ( fields = { \"Job description\" : \"bbb.yy.ss\" }) with pytest . raises ( AttributeError , match = \"Foo' object has no attribute 'yyy'\" ): item_list_2 . to_df ( fields = { \"Job description\" : \"bb.yyy.ss\" }) with pytest . raises ( AttributeError , match = \"Bar' object has no attribute 'sss'\" ): item_list_2 . to_df ( fields = { \"Job description\" : \"bb.yy.sss\" })","title":"Accessing nested field values"},{"location":"reference_guides/primitive_generators/","text":"Primitive generators # Import the primitive generator and helper function used below. from tohu.primitive_generators import * from tohu.utils import print_generated_sequence This section demonstrates the primitive generators available in tohu . Constant Boolean Integer Float HashDigest FakerGenerator SelectOne Constant \u00b6 The Constant generator produces a sequence whose items all have the same fixed value. g = Constant ( \"quux\" ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: quux, quux, quux, quux, quux, quux, quux, quux, quux, quux Boolean \u00b6 The Boolean generator produces a sequence of True / False values, where True is returned with probability p . g = Boolean ( p = 0.3 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: True, False, False, False, False, True, False, False, False, False Integer \u00b6 The Integer generator produces random integers in the range between low and high (both inclusive). g = Integer ( low = 100 , high = 200 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 115, 139, 164, 183, 194, 130, 145, 152, 125, 132 Float \u00b6 The Float generator produces random floating point numbers x in the range low <= x <= high . g = Float ( low = 2.0 , high = 4.0 ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 2.240980952225195 2.618570007385167 3.9058397807167204 3.478847343294601 2.710360026563966 It is possible to truncate generated values to a given number of digits by specifying the ndigits argument. g0 = Float ( low = 2.0 , high = 4.0 , ndigits = 0 ) g3 = Float ( low = 2.0 , high = 4.0 , ndigits = 3 ) g5 = Float ( low = 2.0 , high = 4.0 , ndigits = 5 ) print_generated_sequence ( g0 , 10 , seed = 99999 ) print_generated_sequence ( g3 , 10 , seed = 99999 ) print_generated_sequence ( g5 , 10 , seed = 99999 ) Generated sequence: 2.0, 3.0, 4.0, 3.0, 3.0, 2.0, 3.0, 4.0, 3.0, 4.0 Generated sequence: 2.241, 2.619, 3.906, 3.479, 2.71, 2.405, 2.811, 3.848, 3.212, 3.646 Generated sequence: 2.24098, 2.61857, 3.90584, 3.47885, 2.71036, 2.40515, 2.81102, 3.8477, 3.21194, 3.64639 HashDigest \u00b6 The HashDigest generator produces a sequence of hex strings representing hash digest values. By default, it produces hex strings of the specified length. g = HashDigest ( length = 6 ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 4B4D02 9097BC EC6DF8 B3E6CA EE19B1 Instead of hex strings, the generator can produce the equivalent byte strings by setting as_bytes=True . g = HashDigest ( length = 3 , as_bytes = True ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: b'KM\\x02' b'\\x90\\x97\\xbc' b'\\xecm\\xf8' b'\\xb3\\xe6\\xca' b'\\xee\\x19\\xb1' The lowercase keyword can be used to produce hex strings with lowercase characters (note this has no effect when as_bytes=True ). g = HashDigest ( length = 8 , lowercase = True ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 4b4d0235, 9097bc5e, ec6df8fc, b3e6caf3, ee19b1d3, 9fc0b7fd, 6f07a116, ac591849, 91fa77c5, f863c55d FakerGenerator \u00b6 FakerGenerator allows to produce elements using any of the providers provided by the Faker package. The provider is specified using the method argument. Examples: g = FakerGenerator ( method = \"name\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: Eric Benton Heather Harris Thomas Obrien Amy Cook Kenneth Robles g = FakerGenerator ( method = \"address\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 356 Richard Valleys Madelineton, ME 76205 25835 Deborah Creek Rhondaport, WI 54356 9826 Sullivan Brook Apt. 610 Duncanfort, PA 04949 6408 Gabrielle Stream East Margaret, KY 58692 51904 Garcia Walks Port Philip, RI 10457 SelectOne \u00b6 SelectOne produces elements that are randomly chosen from a fixed sequence. numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] g = SelectOne ( numbers ) print_generated_sequence ( g , 20 , seed = 99999 ) Generated sequence: 2, 5, 9, 4, 6, 7, 4, 5, 7, 10, 10, 9, 4, 1, 6, 9, 7, 10, 5, 5","title":"Primitive generators"},{"location":"reference_guides/primitive_generators/#constant","text":"The Constant generator produces a sequence whose items all have the same fixed value. g = Constant ( \"quux\" ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: quux, quux, quux, quux, quux, quux, quux, quux, quux, quux","title":"Constant"},{"location":"reference_guides/primitive_generators/#boolean","text":"The Boolean generator produces a sequence of True / False values, where True is returned with probability p . g = Boolean ( p = 0.3 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: True, False, False, False, False, True, False, False, False, False","title":"Boolean"},{"location":"reference_guides/primitive_generators/#integer","text":"The Integer generator produces random integers in the range between low and high (both inclusive). g = Integer ( low = 100 , high = 200 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 115, 139, 164, 183, 194, 130, 145, 152, 125, 132","title":"Integer"},{"location":"reference_guides/primitive_generators/#float","text":"The Float generator produces random floating point numbers x in the range low <= x <= high . g = Float ( low = 2.0 , high = 4.0 ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 2.240980952225195 2.618570007385167 3.9058397807167204 3.478847343294601 2.710360026563966 It is possible to truncate generated values to a given number of digits by specifying the ndigits argument. g0 = Float ( low = 2.0 , high = 4.0 , ndigits = 0 ) g3 = Float ( low = 2.0 , high = 4.0 , ndigits = 3 ) g5 = Float ( low = 2.0 , high = 4.0 , ndigits = 5 ) print_generated_sequence ( g0 , 10 , seed = 99999 ) print_generated_sequence ( g3 , 10 , seed = 99999 ) print_generated_sequence ( g5 , 10 , seed = 99999 ) Generated sequence: 2.0, 3.0, 4.0, 3.0, 3.0, 2.0, 3.0, 4.0, 3.0, 4.0 Generated sequence: 2.241, 2.619, 3.906, 3.479, 2.71, 2.405, 2.811, 3.848, 3.212, 3.646 Generated sequence: 2.24098, 2.61857, 3.90584, 3.47885, 2.71036, 2.40515, 2.81102, 3.8477, 3.21194, 3.64639","title":"Float"},{"location":"reference_guides/primitive_generators/#hashdigest","text":"The HashDigest generator produces a sequence of hex strings representing hash digest values. By default, it produces hex strings of the specified length. g = HashDigest ( length = 6 ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 4B4D02 9097BC EC6DF8 B3E6CA EE19B1 Instead of hex strings, the generator can produce the equivalent byte strings by setting as_bytes=True . g = HashDigest ( length = 3 , as_bytes = True ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: b'KM\\x02' b'\\x90\\x97\\xbc' b'\\xecm\\xf8' b'\\xb3\\xe6\\xca' b'\\xee\\x19\\xb1' The lowercase keyword can be used to produce hex strings with lowercase characters (note this has no effect when as_bytes=True ). g = HashDigest ( length = 8 , lowercase = True ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 4b4d0235, 9097bc5e, ec6df8fc, b3e6caf3, ee19b1d3, 9fc0b7fd, 6f07a116, ac591849, 91fa77c5, f863c55d","title":"HashDigest"},{"location":"reference_guides/primitive_generators/#fakergenerator","text":"FakerGenerator allows to produce elements using any of the providers provided by the Faker package. The provider is specified using the method argument. Examples: g = FakerGenerator ( method = \"name\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: Eric Benton Heather Harris Thomas Obrien Amy Cook Kenneth Robles g = FakerGenerator ( method = \"address\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 356 Richard Valleys Madelineton, ME 76205 25835 Deborah Creek Rhondaport, WI 54356 9826 Sullivan Brook Apt. 610 Duncanfort, PA 04949 6408 Gabrielle Stream East Margaret, KY 58692 51904 Garcia Walks Port Philip, RI 10457","title":"FakerGenerator"},{"location":"reference_guides/primitive_generators/#selectone","text":"SelectOne produces elements that are randomly chosen from a fixed sequence. numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] g = SelectOne ( numbers ) print_generated_sequence ( g , 20 , seed = 99999 ) Generated sequence: 2, 5, 9, 4, 6, 7, 4, 5, 7, 10, 10, 9, 4, 1, 6, 9, 7, 10, 5, 5","title":"SelectOne"},{"location":"reference_guides/internals/debugging_support/","text":"Debugging Support In Tohu from tohu import Integer , HashDigest , CustomGenerator Every tohu generator instance has an internal tohu_id . g1 = Integer ( low = 100 , high = 200 ) g2 = HashDigest ( length = 8 ) # NBVAL_IGNORE_OUTPUT print ( g1 . tohu_id ) print ( g2 . tohu_id ) d4bebd 8e8319 This is also included when generators are printed. print ( g1 ) print ( g2 ) <Integer (id=d4bebd)> <HashDigest (id=8e8319)> For debugging purposes, it is possible to assign an explicit name, which can make it easier to identify tohu generators when working out dependencies between them. g1 . set_tohu_name ( \"g1\" ) <g1: Integer (id=d4bebd)> A common way to do this is when defining custom generators, like this: class QuuxGenerator ( CustomGenerator ): aa = Integer ( low = 100 , high = 200 ) bb = HashDigest ( length = 8 ) . set_tohu_name ( \"bb\" ) QuuxGenerator . bb <bb: HashDigest (id=f32938)> g = QuuxGenerator () print ( g ) print ( g . aa ) print ( g . bb ) <QuuxGenerator (id=223cd2)> <Integer (id=8c1902)> <bb: HashDigest (id=21e033)>","title":"Debugging support"},{"location":"reference_guides/internals/loop_variable/","text":"LoopVariable Initialisation .cur_value .__next__() .advance() .reset() The LoopVariable class is used internally to implement looping via the @foreach decorator. Initialisation \u00b6 from tohu.looping import LoopVariable xx = LoopVariable ( name = \"foo\" , values = [ 11 , 22 , 33 ]) A LoopVariable is a valid tohu generator in its own right: from tohu.base import TohuBaseGenerator isinstance ( xx , TohuBaseGenerator ) True .cur_value \u00b6 The current value of a loop variable is accessible via the .cur_value attribute. Initially this is set to the first value in the sequence passed via the values argument during initialisation. print ( xx . cur_value ) 11 .__next__() \u00b6 When calling next() on a loop variable, it will always return the current value. print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) 11 11 11 11 .advance() \u00b6 The current value can be advanced to the next one by calling .advance() xx . advance () print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) 22 22 22 xx . advance () print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) 33 33 33 Once all values have been cycled through, calling .advance() again will cause an IndexError . import pytest with pytest . raises ( IndexError , match = \"Loop variable has been exhausted.\" ): xx . advance () .reset() \u00b6 When calling .reset() on a loop variable, it will reset the generator to its initial state so that it can be iterated over again in the same way as before. xx . reset () print ( next ( xx )) print ( next ( xx )) xx . advance () print ( next ( xx )) print ( next ( xx )) xx . advance () print ( next ( xx )) print ( next ( xx )) 11 11 22 22 33 33","title":"Loop variable"},{"location":"reference_guides/internals/loop_variable/#initialisation","text":"from tohu.looping import LoopVariable xx = LoopVariable ( name = \"foo\" , values = [ 11 , 22 , 33 ]) A LoopVariable is a valid tohu generator in its own right: from tohu.base import TohuBaseGenerator isinstance ( xx , TohuBaseGenerator ) True","title":"Initialisation"},{"location":"reference_guides/internals/loop_variable/#cur_value","text":"The current value of a loop variable is accessible via the .cur_value attribute. Initially this is set to the first value in the sequence passed via the values argument during initialisation. print ( xx . cur_value ) 11","title":".cur_value"},{"location":"reference_guides/internals/loop_variable/#__next__","text":"When calling next() on a loop variable, it will always return the current value. print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) 11 11 11 11","title":".__next__()"},{"location":"reference_guides/internals/loop_variable/#advance","text":"The current value can be advanced to the next one by calling .advance() xx . advance () print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) 22 22 22 xx . advance () print ( next ( xx )) print ( next ( xx )) print ( next ( xx )) 33 33 33 Once all values have been cycled through, calling .advance() again will cause an IndexError . import pytest with pytest . raises ( IndexError , match = \"Loop variable has been exhausted.\" ): xx . advance ()","title":".advance()"},{"location":"reference_guides/internals/loop_variable/#reset","text":"When calling .reset() on a loop variable, it will reset the generator to its initial state so that it can be iterated over again in the same way as before. xx . reset () print ( next ( xx )) print ( next ( xx )) xx . advance () print ( next ( xx )) print ( next ( xx )) xx . advance () print ( next ( xx )) print ( next ( xx )) 11 11 22 22 33 33","title":".reset()"},{"location":"reference_guides/internals/seed_generator/","text":"SeedGenerator The SeedGenerator is is used internally by tohu to produce seeds with which to reset other generators (for example, the constituent generators in a CustomGenerator instance). It produces integers in the range from 0 to 2^32-1, as illustrated below. from tohu.base import SeedGenerator seed_generator = SeedGenerator () seed_generator . reset ( 12345 ) for _ in range ( 10 ): print ( next ( seed_generator )) 831769172 2430986565 694443915 1859447115 2376066489 2164385946 636282949 3087940365 1466990855 101022850","title":"Seed generator"},{"location":"reference_guides/internals/spawning_and_cloning_generators/","text":"Spawning and cloning generators Spawning generators \u00b6 Calling the spawn() method on any generator produced an exact copy if itself. It is of the same type, initialised with the same parameters and initially has the same state. However, they are otherwise completely independent and resetting one of them has no influence on the other (this is different for cloned generators, see below). from tohu import Integer from tohu.utils import print_generated_sequence g = Integer ( 100 , 200 ) . reset ( seed = 12345 ) h = g . spawn () Initially, h is in the same state as g so they will produce the same elements print_generated_sequence ( g , num = 10 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 153, 193, 101, 138, 147, 124, 134, 172, 155, 120 Generated sequence: 153, 193, 101, 138, 147 If we reset g with a different seed, it will start producing different elements (but h will continue to produce the same elements that g did; notice that the following five produced by h are the same as the last five for g in the previous output). g . reset ( seed = 99999 ) print_generated_sequence ( g , num = 5 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 115, 139, 164, 183, 194 Generated sequence: 124, 134, 172, 155, 120 Cloning generators \u00b6 Cloning a generator g also produces an identical copy g_clone . However, unlike in spawning the two are now \"linked\" in the sense that whenever g is reset it will also automatically reset g_clone using the same seed (but not vice versa!). TODO : Should it even be allowed to reset a cloned generator? Or shall we disallow it for now? g = Integer ( 100 , 200 ) . reset ( seed = 12345 ) h = g . clone () print_generated_sequence ( g , num = 10 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 153, 193, 101, 138, 147, 124, 134, 172, 155, 120 Generated sequence: 153, 193, 101, 138, 147 g . reset ( seed = 99999 ) print_generated_sequence ( g , num = 5 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 115, 139, 164, 183, 194 Generated sequence: 115, 139, 164, 183, 194","title":"Spawning and cloning generators"},{"location":"reference_guides/internals/spawning_and_cloning_generators/#spawning-generators","text":"Calling the spawn() method on any generator produced an exact copy if itself. It is of the same type, initialised with the same parameters and initially has the same state. However, they are otherwise completely independent and resetting one of them has no influence on the other (this is different for cloned generators, see below). from tohu import Integer from tohu.utils import print_generated_sequence g = Integer ( 100 , 200 ) . reset ( seed = 12345 ) h = g . spawn () Initially, h is in the same state as g so they will produce the same elements print_generated_sequence ( g , num = 10 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 153, 193, 101, 138, 147, 124, 134, 172, 155, 120 Generated sequence: 153, 193, 101, 138, 147 If we reset g with a different seed, it will start producing different elements (but h will continue to produce the same elements that g did; notice that the following five produced by h are the same as the last five for g in the previous output). g . reset ( seed = 99999 ) print_generated_sequence ( g , num = 5 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 115, 139, 164, 183, 194 Generated sequence: 124, 134, 172, 155, 120","title":"Spawning generators"},{"location":"reference_guides/internals/spawning_and_cloning_generators/#cloning-generators","text":"Cloning a generator g also produces an identical copy g_clone . However, unlike in spawning the two are now \"linked\" in the sense that whenever g is reset it will also automatically reset g_clone using the same seed (but not vice versa!). TODO : Should it even be allowed to reset a cloned generator? Or shall we disallow it for now? g = Integer ( 100 , 200 ) . reset ( seed = 12345 ) h = g . clone () print_generated_sequence ( g , num = 10 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 153, 193, 101, 138, 147, 124, 134, 172, 155, 120 Generated sequence: 153, 193, 101, 138, 147 g . reset ( seed = 99999 ) print_generated_sequence ( g , num = 5 ) print_generated_sequence ( h , num = 5 ) Generated sequence: 115, 139, 164, 183, 194 Generated sequence: 115, 139, 164, 183, 194","title":"Cloning generators"},{"location":"reference_guides/internals/tohu_items_class/","text":"Tohu Items make_tohu_items_class() derive_tohu_items_class_name() make_tohu_items_class() \u00b6 TODO: add a short overview of what this section is about. from tohu.tohu_items_class import make_tohu_items_class quux_cls = make_tohu_items_class ( \"Quux\" , [ \"aa\" , \"bb\" , \"cc\" ]) print ( quux_cls ) <class 'tohu.tohu_items_class.Quux'> This can then be used to create individual items with these attributes. quux1 = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) quux2 = quux_cls ( aa = 20 , bb = \"bar\" , cc = False ) print ( quux1 ) print ( quux2 ) Quux(aa=10, bb='foo', cc=True) Quux(aa=20, bb='bar', cc=False) This is used internally by custom generators when producing items. These items can be compared, too: quux1_new = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) Items compare equal if they contain the same values (even if they are technically different objects). assert quux1 is quux1 assert quux1 == quux1 assert quux1 is not quux1_new assert quux1 == quux1_new assert quux1 != quux2 For convenience, tohu items can also directly be compared with dictionaries or tuples. assert quux1 == ( 10 , \"foo\" , True ) assert quux1 == { \"aa\" : 10 , \"bb\" : \"foo\" , \"cc\" : True } assert quux1 != ( 20 , \"bar\" , False ) We can retrieve the field names of an item using the field_names attribute. quux1 . field_names ['aa', 'bb', 'cc'] And we can convert it to a dict or a tuple using convenience helper methods. quux1 . as_dict () {'aa': 10, 'bb': 'foo', 'cc': True} quux1 . as_tuple () (10, 'foo', True) derive_tohu_items_class_name() \u00b6 from tohu.tohu_items_class import derive_tohu_items_class_name The helper function derive_tohu_items_class_name takes the name of a custom generator class as argument and simply strips the ...Generator suffix. derive_tohu_items_class_name ( \"QuuxGenerator\" ) 'Quux' derive_tohu_items_class_name ( \"FooBarGenerator\" ) 'FooBar' If the class name doesn't end with Generator , it raises an error. #derive_tohu_items_class_name(\"Quux\")","title":"Tohu items class"},{"location":"reference_guides/internals/tohu_items_class/#make_tohu_items_class","text":"TODO: add a short overview of what this section is about. from tohu.tohu_items_class import make_tohu_items_class quux_cls = make_tohu_items_class ( \"Quux\" , [ \"aa\" , \"bb\" , \"cc\" ]) print ( quux_cls ) <class 'tohu.tohu_items_class.Quux'> This can then be used to create individual items with these attributes. quux1 = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) quux2 = quux_cls ( aa = 20 , bb = \"bar\" , cc = False ) print ( quux1 ) print ( quux2 ) Quux(aa=10, bb='foo', cc=True) Quux(aa=20, bb='bar', cc=False) This is used internally by custom generators when producing items. These items can be compared, too: quux1_new = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) Items compare equal if they contain the same values (even if they are technically different objects). assert quux1 is quux1 assert quux1 == quux1 assert quux1 is not quux1_new assert quux1 == quux1_new assert quux1 != quux2 For convenience, tohu items can also directly be compared with dictionaries or tuples. assert quux1 == ( 10 , \"foo\" , True ) assert quux1 == { \"aa\" : 10 , \"bb\" : \"foo\" , \"cc\" : True } assert quux1 != ( 20 , \"bar\" , False ) We can retrieve the field names of an item using the field_names attribute. quux1 . field_names ['aa', 'bb', 'cc'] And we can convert it to a dict or a tuple using convenience helper methods. quux1 . as_dict () {'aa': 10, 'bb': 'foo', 'cc': True} quux1 . as_tuple () (10, 'foo', True)","title":"make_tohu_items_class()"},{"location":"reference_guides/internals/tohu_items_class/#derive_tohu_items_class_name","text":"from tohu.tohu_items_class import derive_tohu_items_class_name The helper function derive_tohu_items_class_name takes the name of a custom generator class as argument and simply strips the ...Generator suffix. derive_tohu_items_class_name ( \"QuuxGenerator\" ) 'Quux' derive_tohu_items_class_name ( \"FooBarGenerator\" ) 'FooBar' If the class name doesn't end with Generator , it raises an error. #derive_tohu_items_class_name(\"Quux\")","title":"derive_tohu_items_class_name()"},{"location":"tutorials/","text":"Introduction This section contains Tutorials . A tutorial: is learning-oriented allows the newcomer to get started is a lesson (See here for context and more information.)","title":"Introduction"},{"location":"tutorials/custom_generators/","text":"Custom Generators This section introduces \"custom generators\", which allow to combine individual generators into a single new entity. Introduction Example: Generating \"Person\" Records Introduction \u00b6 Primitive generators are nice, but on their own they are barely more useful than existing random number generators such as Python's built-in random module, numpy 's random module or the faker package. (Perhaps the most useful aspect about primitive generators on their own is that they present a consistent interface for generating random items of different types, but this alone rarely justifies the existence of a package like tohu .) The real power of tohu lies in how it allows to easily combine other generators into \"compound\" generators. In tohu these are called CustomGenerators (TODO: should this name be changed to CompoundGenerator ?). Example: Generating \"Person\" Records \u00b6 Imagine you want to create synthetic data that represents information about a person. For each person you may want to create a name, an age, and a job decription. As we learned before in the section about primitive generators, we can generate these kinds of data separately, but how do we combine them into proper \"Person\" records? The answer is, we use a CustomGenerator . Let's look at an example. As before, we present the full example first and then analyse it in more detail. from tohu import FakerGenerator , Integer , CustomGenerator class PersonGenerator ( CustomGenerator ): name = FakerGenerator ( method = \"name\" ) age = Integer ( 0 , 99 ) job = FakerGenerator ( method = \"job\" ) g = PersonGenerator () items = g . generate ( num = 5 , seed = 12345 ) items <ItemList containing 5 items> list ( items ) [Person(name='Katherine Alvarez', age=2, job='Local government officer'), Person(name='Eric Hancock', age=54, job='Librarian, public'), Person(name='Daniel Chase', age=56, job='Multimedia programmer'), Person(name='Kenneth Walls', age=80, job='Sales promotion account executive'), Person(name='William Snow', age=78, job='Meteorologist')] While in many respects an ItemList behaves like a regular list, it is more powerful. For example, it supports exporting its items to a pandas dataframe. items . to_df () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age job 0 Katherine Alvarez 2 Local government officer 1 Eric Hancock 54 Librarian, public 2 Daniel Chase 56 Multimedia programmer 3 Kenneth Walls 80 Sales promotion account executive 4 William Snow 78 Meteorologist","title":"Custom generators"},{"location":"tutorials/custom_generators/#introduction","text":"Primitive generators are nice, but on their own they are barely more useful than existing random number generators such as Python's built-in random module, numpy 's random module or the faker package. (Perhaps the most useful aspect about primitive generators on their own is that they present a consistent interface for generating random items of different types, but this alone rarely justifies the existence of a package like tohu .) The real power of tohu lies in how it allows to easily combine other generators into \"compound\" generators. In tohu these are called CustomGenerators (TODO: should this name be changed to CompoundGenerator ?).","title":"Introduction"},{"location":"tutorials/custom_generators/#example-generating-person-records","text":"Imagine you want to create synthetic data that represents information about a person. For each person you may want to create a name, an age, and a job decription. As we learned before in the section about primitive generators, we can generate these kinds of data separately, but how do we combine them into proper \"Person\" records? The answer is, we use a CustomGenerator . Let's look at an example. As before, we present the full example first and then analyse it in more detail. from tohu import FakerGenerator , Integer , CustomGenerator class PersonGenerator ( CustomGenerator ): name = FakerGenerator ( method = \"name\" ) age = Integer ( 0 , 99 ) job = FakerGenerator ( method = \"job\" ) g = PersonGenerator () items = g . generate ( num = 5 , seed = 12345 ) items <ItemList containing 5 items> list ( items ) [Person(name='Katherine Alvarez', age=2, job='Local government officer'), Person(name='Eric Hancock', age=54, job='Librarian, public'), Person(name='Daniel Chase', age=56, job='Multimedia programmer'), Person(name='Kenneth Walls', age=80, job='Sales promotion account executive'), Person(name='William Snow', age=78, job='Meteorologist')] While in many respects an ItemList behaves like a regular list, it is more powerful. For example, it supports exporting its items to a pandas dataframe. items . to_df () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age job 0 Katherine Alvarez 2 Local government officer 1 Eric Hancock 54 Librarian, public 2 Daniel Chase 56 Multimedia programmer 3 Kenneth Walls 80 Sales promotion account executive 4 William Snow 78 Meteorologist","title":"Example: Generating \"Person\" Records"},{"location":"tutorials/looping_with_%40foreach/","text":"Looping with @foreach Single loop variable Multiple loop variables (at the same level) Nested loop variables Placeholder loop variables (filling in values later) Single loop variable \u00b6 from tohu import FakerGenerator , Integer , CustomGenerator , foreach @foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" , \"2000-01-03\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () g <@foreach-wrapped <MatchRecordGenerator (id=c37185)> > list ( g . generate_as_stream ( num_iterations = [ 2 , 4 , 3 ], seed = 11111 )) [MatchRecord(date='2000-01-01', player='Ashlee', points_scored=36), MatchRecord(date='2000-01-01', player='Kelly', points_scored=78), MatchRecord(date='2000-01-02', player='Jennifer', points_scored=13), MatchRecord(date='2000-01-02', player='Sandra', points_scored=16), MatchRecord(date='2000-01-02', player='Todd', points_scored=93), MatchRecord(date='2000-01-02', player='Stephen', points_scored=6), MatchRecord(date='2000-01-03', player='Joanna', points_scored=3), MatchRecord(date='2000-01-03', player='John', points_scored=36), MatchRecord(date='2000-01-03', player='Robert', points_scored=66)] Since we specified three dates in the @foreach call above, we also must provide three values in the list nums (so that the generate_as_stream() method knows how many elements to produce for each generation. It is allowed for the list to be longer (in which case subsequent elements are ignored) or shorter (in which case fewer loop iterations are run), as shown below. # Here `num` has fewer elements than there are dates we're looping over, # so the loop iteration for the third date doesn't happen. list ( g . generate_as_stream ( num_iterations = [ 2 , 3 ], seed = 11111 )) [MatchRecord(date='2000-01-01', player='Ashlee', points_scored=36), MatchRecord(date='2000-01-01', player='Kelly', points_scored=78), MatchRecord(date='2000-01-02', player='Jennifer', points_scored=13), MatchRecord(date='2000-01-02', player='Sandra', points_scored=16), MatchRecord(date='2000-01-02', player='Todd', points_scored=93)] # Here `num` has more elements than there are dates we're looping over, # so the additional elements are ignored for looping. list ( g . generate_as_stream ( num_iterations = [ 2 , 4 , 3 , 5 , 1 , 2 ], seed = 11111 )) [MatchRecord(date='2000-01-01', player='Ashlee', points_scored=36), MatchRecord(date='2000-01-01', player='Kelly', points_scored=78), MatchRecord(date='2000-01-02', player='Jennifer', points_scored=13), MatchRecord(date='2000-01-02', player='Sandra', points_scored=16), MatchRecord(date='2000-01-02', player='Todd', points_scored=93), MatchRecord(date='2000-01-02', player='Stephen', points_scored=6), MatchRecord(date='2000-01-03', player='Joanna', points_scored=3), MatchRecord(date='2000-01-03', player='John', points_scored=36), MatchRecord(date='2000-01-03', player='Robert', points_scored=66)] Multiple loop variables (at the same level) \u00b6 @foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" , \"2000-01-03\" ], match_venue = [ \"Town A\" , \"Town B\" , \"Town C\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () Note that in the generated items, the match date and venue are always matched up: g . generate_as_list ( num_iterations = [ 2 , 4 , 3 ], seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-02', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2000-01-02', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-02', venue='Town B', player='Christopher', points_scored=97), MatchRecord(date='2000-01-02', venue='Town B', player='Ian', points_scored=57), MatchRecord(date='2000-01-03', venue='Town C', player='Justin', points_scored=30), MatchRecord(date='2000-01-03', venue='Town C', player='Barbara', points_scored=67), MatchRecord(date='2000-01-03', venue='Town C', player='Heather', points_scored=80)] If one of the loop variables contains more elements than the other, the additional ones are ignored. In other words, we can only do as many loop iterations as specified by the loop variable with the fewest values. Here we can only produce elements for two dates (even though there are four venues). @foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" ], match_venue = [ \"Town A\" , \"Town B\" , \"Town C\" , \"Town D\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () g . generate_as_list ( num_iterations = [ 2 , 4 , 3 , 2 ], seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-02', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2000-01-02', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-02', venue='Town B', player='Christopher', points_scored=97), MatchRecord(date='2000-01-02', venue='Town B', player='Ian', points_scored=57)] Nested loop variables \u00b6 @foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" , \"2000-01-03\" ]) @foreach ( match_venue = [ \"Town A\" , \"Town B\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () g . generate_as_list ( num_iterations = [ 2 , 4 , 3 , 2 ], seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-01', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2000-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-01', venue='Town B', player='Christopher', points_scored=97), MatchRecord(date='2000-01-01', venue='Town B', player='Ian', points_scored=57), MatchRecord(date='2000-01-02', venue='Town A', player='Justin', points_scored=30), MatchRecord(date='2000-01-02', venue='Town A', player='Barbara', points_scored=67), MatchRecord(date='2000-01-02', venue='Town A', player='Heather', points_scored=80), MatchRecord(date='2000-01-02', venue='Town B', player='Michelle', points_scored=52), MatchRecord(date='2000-01-02', venue='Town B', player='Becky', points_scored=53)] def f_num_iterations ( match_date , match_venue ): if match_venue == \"Town A\" : return 3 elif match_venue == \"Town B\" : return 1 else : raise ValueError ( \"Invalid venue\" ) g . generate_as_list ( num_iterations = f_num_iterations , seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-01', venue='Town A', player='Joseph', points_scored=76), MatchRecord(date='2000-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-02', venue='Town A', player='Christopher', points_scored=97), MatchRecord(date='2000-01-02', venue='Town A', player='Ian', points_scored=57), MatchRecord(date='2000-01-02', venue='Town A', player='Justin', points_scored=30), MatchRecord(date='2000-01-02', venue='Town B', player='Barbara', points_scored=67), MatchRecord(date='2000-01-03', venue='Town A', player='Heather', points_scored=80), MatchRecord(date='2000-01-03', venue='Town A', player='Michelle', points_scored=52), MatchRecord(date='2000-01-03', venue='Town A', player='Becky', points_scored=53), MatchRecord(date='2000-01-03', venue='Town B', player='Kayla', points_scored=84)] Placeholder loop variables (filling in values later) \u00b6 import pytest from tohu.looping import PLACEHOLDER , UnassignedValuesError @foreach ( match_date = PLACEHOLDER ) @foreach ( match_venue = [ \"Town A\" , \"Town B\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () with pytest . raises ( UnassignedValuesError , match = \"Loop variable 'match_date' has not been assigned any values.\" ): g . generate_as_list ( num_iterations = 2 , seed = 11111 ) g . foreach ( match_date = [ \"2020-01-01\" , \"2020-01-02\" ]) . generate_as_list ( num_iterations = 2 , seed = 11111 ) [MatchRecord(date='2020-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2020-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2020-01-01', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2020-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2020-01-02', venue='Town A', player='Christopher', points_scored=97), MatchRecord(date='2020-01-02', venue='Town A', player='Ian', points_scored=57), MatchRecord(date='2020-01-02', venue='Town B', player='Justin', points_scored=30), MatchRecord(date='2020-01-02', venue='Town B', player='Barbara', points_scored=67)] g . foreach ( match_date = [ \"2020-01-01\" , \"2020-01-02\" , \"2020-01-03\" ]) . generate_as_list ( num_iterations = 2 , seed = 11111 ) [MatchRecord(date='2020-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2020-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2020-01-01', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2020-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2020-01-02', venue='Town A', player='Christopher', points_scored=97), MatchRecord(date='2020-01-02', venue='Town A', player='Ian', points_scored=57), MatchRecord(date='2020-01-02', venue='Town B', player='Justin', points_scored=30), MatchRecord(date='2020-01-02', venue='Town B', player='Barbara', points_scored=67), MatchRecord(date='2020-01-03', venue='Town A', player='Heather', points_scored=80), MatchRecord(date='2020-01-03', venue='Town A', player='Michelle', points_scored=52), MatchRecord(date='2020-01-03', venue='Town B', player='Becky', points_scored=53), MatchRecord(date='2020-01-03', venue='Town B', player='Kayla', points_scored=84)] with pytest . raises ( UnassignedValuesError , match = \"Loop variable 'match_date' has not been assigned any values.\" ): g . generate_as_list ( num_iterations = 2 , seed = 11111 )","title":"Looping with @foreach"},{"location":"tutorials/looping_with_%40foreach/#single-loop-variable","text":"from tohu import FakerGenerator , Integer , CustomGenerator , foreach @foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" , \"2000-01-03\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () g <@foreach-wrapped <MatchRecordGenerator (id=c37185)> > list ( g . generate_as_stream ( num_iterations = [ 2 , 4 , 3 ], seed = 11111 )) [MatchRecord(date='2000-01-01', player='Ashlee', points_scored=36), MatchRecord(date='2000-01-01', player='Kelly', points_scored=78), MatchRecord(date='2000-01-02', player='Jennifer', points_scored=13), MatchRecord(date='2000-01-02', player='Sandra', points_scored=16), MatchRecord(date='2000-01-02', player='Todd', points_scored=93), MatchRecord(date='2000-01-02', player='Stephen', points_scored=6), MatchRecord(date='2000-01-03', player='Joanna', points_scored=3), MatchRecord(date='2000-01-03', player='John', points_scored=36), MatchRecord(date='2000-01-03', player='Robert', points_scored=66)] Since we specified three dates in the @foreach call above, we also must provide three values in the list nums (so that the generate_as_stream() method knows how many elements to produce for each generation. It is allowed for the list to be longer (in which case subsequent elements are ignored) or shorter (in which case fewer loop iterations are run), as shown below. # Here `num` has fewer elements than there are dates we're looping over, # so the loop iteration for the third date doesn't happen. list ( g . generate_as_stream ( num_iterations = [ 2 , 3 ], seed = 11111 )) [MatchRecord(date='2000-01-01', player='Ashlee', points_scored=36), MatchRecord(date='2000-01-01', player='Kelly', points_scored=78), MatchRecord(date='2000-01-02', player='Jennifer', points_scored=13), MatchRecord(date='2000-01-02', player='Sandra', points_scored=16), MatchRecord(date='2000-01-02', player='Todd', points_scored=93)] # Here `num` has more elements than there are dates we're looping over, # so the additional elements are ignored for looping. list ( g . generate_as_stream ( num_iterations = [ 2 , 4 , 3 , 5 , 1 , 2 ], seed = 11111 )) [MatchRecord(date='2000-01-01', player='Ashlee', points_scored=36), MatchRecord(date='2000-01-01', player='Kelly', points_scored=78), MatchRecord(date='2000-01-02', player='Jennifer', points_scored=13), MatchRecord(date='2000-01-02', player='Sandra', points_scored=16), MatchRecord(date='2000-01-02', player='Todd', points_scored=93), MatchRecord(date='2000-01-02', player='Stephen', points_scored=6), MatchRecord(date='2000-01-03', player='Joanna', points_scored=3), MatchRecord(date='2000-01-03', player='John', points_scored=36), MatchRecord(date='2000-01-03', player='Robert', points_scored=66)]","title":"Single loop variable"},{"location":"tutorials/looping_with_%40foreach/#multiple-loop-variables-at-the-same-level","text":"@foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" , \"2000-01-03\" ], match_venue = [ \"Town A\" , \"Town B\" , \"Town C\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () Note that in the generated items, the match date and venue are always matched up: g . generate_as_list ( num_iterations = [ 2 , 4 , 3 ], seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-02', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2000-01-02', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-02', venue='Town B', player='Christopher', points_scored=97), MatchRecord(date='2000-01-02', venue='Town B', player='Ian', points_scored=57), MatchRecord(date='2000-01-03', venue='Town C', player='Justin', points_scored=30), MatchRecord(date='2000-01-03', venue='Town C', player='Barbara', points_scored=67), MatchRecord(date='2000-01-03', venue='Town C', player='Heather', points_scored=80)] If one of the loop variables contains more elements than the other, the additional ones are ignored. In other words, we can only do as many loop iterations as specified by the loop variable with the fewest values. Here we can only produce elements for two dates (even though there are four venues). @foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" ], match_venue = [ \"Town A\" , \"Town B\" , \"Town C\" , \"Town D\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () g . generate_as_list ( num_iterations = [ 2 , 4 , 3 , 2 ], seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-02', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2000-01-02', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-02', venue='Town B', player='Christopher', points_scored=97), MatchRecord(date='2000-01-02', venue='Town B', player='Ian', points_scored=57)]","title":"Multiple loop variables (at the same level)"},{"location":"tutorials/looping_with_%40foreach/#nested-loop-variables","text":"@foreach ( match_date = [ \"2000-01-01\" , \"2000-01-02\" , \"2000-01-03\" ]) @foreach ( match_venue = [ \"Town A\" , \"Town B\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () g . generate_as_list ( num_iterations = [ 2 , 4 , 3 , 2 ], seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-01', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2000-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-01', venue='Town B', player='Christopher', points_scored=97), MatchRecord(date='2000-01-01', venue='Town B', player='Ian', points_scored=57), MatchRecord(date='2000-01-02', venue='Town A', player='Justin', points_scored=30), MatchRecord(date='2000-01-02', venue='Town A', player='Barbara', points_scored=67), MatchRecord(date='2000-01-02', venue='Town A', player='Heather', points_scored=80), MatchRecord(date='2000-01-02', venue='Town B', player='Michelle', points_scored=52), MatchRecord(date='2000-01-02', venue='Town B', player='Becky', points_scored=53)] def f_num_iterations ( match_date , match_venue ): if match_venue == \"Town A\" : return 3 elif match_venue == \"Town B\" : return 1 else : raise ValueError ( \"Invalid venue\" ) g . generate_as_list ( num_iterations = f_num_iterations , seed = 11111 ) [MatchRecord(date='2000-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2000-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2000-01-01', venue='Town A', player='Joseph', points_scored=76), MatchRecord(date='2000-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2000-01-02', venue='Town A', player='Christopher', points_scored=97), MatchRecord(date='2000-01-02', venue='Town A', player='Ian', points_scored=57), MatchRecord(date='2000-01-02', venue='Town A', player='Justin', points_scored=30), MatchRecord(date='2000-01-02', venue='Town B', player='Barbara', points_scored=67), MatchRecord(date='2000-01-03', venue='Town A', player='Heather', points_scored=80), MatchRecord(date='2000-01-03', venue='Town A', player='Michelle', points_scored=52), MatchRecord(date='2000-01-03', venue='Town A', player='Becky', points_scored=53), MatchRecord(date='2000-01-03', venue='Town B', player='Kayla', points_scored=84)]","title":"Nested loop variables"},{"location":"tutorials/looping_with_%40foreach/#placeholder-loop-variables-filling-in-values-later","text":"import pytest from tohu.looping import PLACEHOLDER , UnassignedValuesError @foreach ( match_date = PLACEHOLDER ) @foreach ( match_venue = [ \"Town A\" , \"Town B\" ]) class MatchRecordGenerator ( CustomGenerator ): date = match_date venue = match_venue player = FakerGenerator ( method = \"first_name\" ) points_scored = Integer ( 0 , 100 ) g = MatchRecordGenerator () with pytest . raises ( UnassignedValuesError , match = \"Loop variable 'match_date' has not been assigned any values.\" ): g . generate_as_list ( num_iterations = 2 , seed = 11111 ) g . foreach ( match_date = [ \"2020-01-01\" , \"2020-01-02\" ]) . generate_as_list ( num_iterations = 2 , seed = 11111 ) [MatchRecord(date='2020-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2020-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2020-01-01', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2020-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2020-01-02', venue='Town A', player='Christopher', points_scored=97), MatchRecord(date='2020-01-02', venue='Town A', player='Ian', points_scored=57), MatchRecord(date='2020-01-02', venue='Town B', player='Justin', points_scored=30), MatchRecord(date='2020-01-02', venue='Town B', player='Barbara', points_scored=67)] g . foreach ( match_date = [ \"2020-01-01\" , \"2020-01-02\" , \"2020-01-03\" ]) . generate_as_list ( num_iterations = 2 , seed = 11111 ) [MatchRecord(date='2020-01-01', venue='Town A', player='Cindy', points_scored=79), MatchRecord(date='2020-01-01', venue='Town A', player='Melanie', points_scored=2), MatchRecord(date='2020-01-01', venue='Town B', player='Joseph', points_scored=76), MatchRecord(date='2020-01-01', venue='Town B', player='Linda', points_scored=94), MatchRecord(date='2020-01-02', venue='Town A', player='Christopher', points_scored=97), MatchRecord(date='2020-01-02', venue='Town A', player='Ian', points_scored=57), MatchRecord(date='2020-01-02', venue='Town B', player='Justin', points_scored=30), MatchRecord(date='2020-01-02', venue='Town B', player='Barbara', points_scored=67), MatchRecord(date='2020-01-03', venue='Town A', player='Heather', points_scored=80), MatchRecord(date='2020-01-03', venue='Town A', player='Michelle', points_scored=52), MatchRecord(date='2020-01-03', venue='Town B', player='Becky', points_scored=53), MatchRecord(date='2020-01-03', venue='Town B', player='Kayla', points_scored=84)] with pytest . raises ( UnassignedValuesError , match = \"Loop variable 'match_date' has not been assigned any values.\" ): g . generate_as_list ( num_iterations = 2 , seed = 11111 )","title":"Placeholder loop variables (filling in values later)"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/","text":"Primitive Generators - The Basic Building Blocks Introduction First example: using Integer to produce random integers Analysing the example Creating the Integer generator Resetting the generator Producing individual random values Producing a sequence of random values Second example: producing random HashDigest values Summary And Next Steps Introduction \u00b6 The most fundamental building blocks of tohu are the so-called \"primitive\" generators. A primitive generator is simply a random generator which knows how to produce values of a specific \"type\" (in a slightly loose sense of the word). For example, there are primitive generators which produce random integers, random boolean values, random names, etc. (see here for a full list). The reason they are called \"primitive\" is because they do not depend on any other generators in tohu , and they can be combined into more complex generators (see subsequent sections). This section illustrates how to create and use primitive generators directly. Note that in practical use you will rarely need or want to create them manually as we do here - typically, they will be created as part of a CustomGenerator (TODO: see section [...]). However, it is useful to get a feel for how they work under the hood, so let's look at an example. First example: using Integer to produce random integers \u00b6 For our first example, let's use the Integer generator, which produces random integers in a given range. Here is the full code snippet and its output (we will look at this line by line in the next section). from tohu.primitive_generators import Integer # Create an instance of an Integer generator g = Integer ( 100 , 200 ) g . reset ( seed = 12345 ) # Produce a single value print ( next ( g )) # Produce a few more values manually for _ in range ( 3 ): print ( next ( g )) # Produce a sequence of values #g.generate(num=10, seed=12345) 153 193 101 138 Analysing the example \u00b6 Creating the Integer generator \u00b6 First we create an Integer generator that will produce values between 100 and 200. g = Integer ( 100 , 200 ) Resetting the generator \u00b6 Before we actually make it produce any values, we first reset the generator. The purpose of this is to initialize the internal (pseudo-)random number generator so that the output is reproducible. The seed argument which we pass to the reset method can have any value. As long as you pass the same seed the generator will produce the same sequence of output values, which ensures reproducibility. g . reset ( seed = 12345 ) <Integer (id=1273e4)> Producing individual random values \u00b6 Now that we have a primitive generator in a well-defined state, how can we produce values using this generator? One way of doing this is to call next() on it, which will ask g to produce a single new value for us. print ( next ( g )) 153 We can do this as many times as we want, and each time g will produce a new random integer in the range [100, 200] . Let's get five more. for _ in range ( 5 ): print ( next ( g )) 193 101 138 147 124 Producing a sequence of random values \u00b6 While this works ok, it quickly becomes cumbersome if we need a lot of values. A more convenient way is to call the generate_as_list method. We can pass the number of elements we want, as well as (optionally) a seed. If the seed is given, this internally calls reset , which ensures that the returned sequence is reproducible (see above). g . generate_as_list ( num = 15 , seed = 99999 ) [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] This is much more convenient, and often the right choice. However, if num is very big then it may be expensive (both in terms of time and memory) to generate all elements at once and store them in a huge list. An alternative would be to call generate_as_stream instead. The result is a Python generator object, and we can iterate over this to obtain the elements sequentially (but this happens in a \"lazy\" fashion, so it is much more time and memory efficient. result = g . generate_as_stream ( num = 15 , seed = 99999 ) print ( result ) <generator object TohuBaseGenerator.generate_as_stream at 0x10f2eab30> [ x for x in result ] [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] Beware that as usual with Python generator objects, once you have iterated over the result it will be exhausted so you can't iterate over it a second time, or else you won't get any elements: [ x for x in result ] [] You should therefore carefully choose which method of generating items is best for your use case. For interactive exploration it is often more convenient to generate lists because they don't need as careful treatment, but if you need to be careful with performance or memory efficiency you can use the stream method instead. Second example: producing random HashDigest values \u00b6 Let's look at another example using a different primitive generator. We choose HashDigest . This produces random strings that look like hash values. The example follows the same pattern as above: Create an instance of the HashDigest generator. Reset it to ensure the output is reproducible. Produce a sequence of elements by calling the generate method. from tohu.primitive_generators import HashDigest g = HashDigest ( length = 8 , lowercase = True ) g . reset ( seed = 99999 ) for _ in range ( 5 ): print ( next ( g )) 4b4d0235 9097bc5e ec6df8fc b3e6caf3 ee19b1d3 g . generate_as_list ( num = 5 , seed = 99999 ) ['4b4d0235', '9097bc5e', 'ec6df8fc', 'b3e6caf3', 'ee19b1d3'] Summary And Next Steps \u00b6 TODO","title":"Primitive generators the basic building blocks"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#introduction","text":"The most fundamental building blocks of tohu are the so-called \"primitive\" generators. A primitive generator is simply a random generator which knows how to produce values of a specific \"type\" (in a slightly loose sense of the word). For example, there are primitive generators which produce random integers, random boolean values, random names, etc. (see here for a full list). The reason they are called \"primitive\" is because they do not depend on any other generators in tohu , and they can be combined into more complex generators (see subsequent sections). This section illustrates how to create and use primitive generators directly. Note that in practical use you will rarely need or want to create them manually as we do here - typically, they will be created as part of a CustomGenerator (TODO: see section [...]). However, it is useful to get a feel for how they work under the hood, so let's look at an example.","title":"Introduction"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#first-example-using-integer-to-produce-random-integers","text":"For our first example, let's use the Integer generator, which produces random integers in a given range. Here is the full code snippet and its output (we will look at this line by line in the next section). from tohu.primitive_generators import Integer # Create an instance of an Integer generator g = Integer ( 100 , 200 ) g . reset ( seed = 12345 ) # Produce a single value print ( next ( g )) # Produce a few more values manually for _ in range ( 3 ): print ( next ( g )) # Produce a sequence of values #g.generate(num=10, seed=12345) 153 193 101 138","title":"First example: using Integer to produce random integers"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#analysing-the-example","text":"","title":"Analysing the example"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#creating-the-integer-generator","text":"First we create an Integer generator that will produce values between 100 and 200. g = Integer ( 100 , 200 )","title":"Creating the Integer generator"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#resetting-the-generator","text":"Before we actually make it produce any values, we first reset the generator. The purpose of this is to initialize the internal (pseudo-)random number generator so that the output is reproducible. The seed argument which we pass to the reset method can have any value. As long as you pass the same seed the generator will produce the same sequence of output values, which ensures reproducibility. g . reset ( seed = 12345 ) <Integer (id=1273e4)>","title":"Resetting the generator"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#producing-individual-random-values","text":"Now that we have a primitive generator in a well-defined state, how can we produce values using this generator? One way of doing this is to call next() on it, which will ask g to produce a single new value for us. print ( next ( g )) 153 We can do this as many times as we want, and each time g will produce a new random integer in the range [100, 200] . Let's get five more. for _ in range ( 5 ): print ( next ( g )) 193 101 138 147 124","title":"Producing individual random values"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#producing-a-sequence-of-random-values","text":"While this works ok, it quickly becomes cumbersome if we need a lot of values. A more convenient way is to call the generate_as_list method. We can pass the number of elements we want, as well as (optionally) a seed. If the seed is given, this internally calls reset , which ensures that the returned sequence is reproducible (see above). g . generate_as_list ( num = 15 , seed = 99999 ) [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] This is much more convenient, and often the right choice. However, if num is very big then it may be expensive (both in terms of time and memory) to generate all elements at once and store them in a huge list. An alternative would be to call generate_as_stream instead. The result is a Python generator object, and we can iterate over this to obtain the elements sequentially (but this happens in a \"lazy\" fashion, so it is much more time and memory efficient. result = g . generate_as_stream ( num = 15 , seed = 99999 ) print ( result ) <generator object TohuBaseGenerator.generate_as_stream at 0x10f2eab30> [ x for x in result ] [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] Beware that as usual with Python generator objects, once you have iterated over the result it will be exhausted so you can't iterate over it a second time, or else you won't get any elements: [ x for x in result ] [] You should therefore carefully choose which method of generating items is best for your use case. For interactive exploration it is often more convenient to generate lists because they don't need as careful treatment, but if you need to be careful with performance or memory efficiency you can use the stream method instead.","title":"Producing a sequence of random values"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#second-example-producing-random-hashdigest-values","text":"Let's look at another example using a different primitive generator. We choose HashDigest . This produces random strings that look like hash values. The example follows the same pattern as above: Create an instance of the HashDigest generator. Reset it to ensure the output is reproducible. Produce a sequence of elements by calling the generate method. from tohu.primitive_generators import HashDigest g = HashDigest ( length = 8 , lowercase = True ) g . reset ( seed = 99999 ) for _ in range ( 5 ): print ( next ( g )) 4b4d0235 9097bc5e ec6df8fc b3e6caf3 ee19b1d3 g . generate_as_list ( num = 5 , seed = 99999 ) ['4b4d0235', '9097bc5e', 'ec6df8fc', 'b3e6caf3', 'ee19b1d3']","title":"Second example: producing random HashDigest values"},{"location":"tutorials/primitive_generators_the_basic_building_blocks/#summary-and-next-steps","text":"TODO","title":"Summary And Next Steps"}]}