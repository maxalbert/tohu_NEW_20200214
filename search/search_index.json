{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contents TODO: Add a brief overview of the project here. Documentation: Tutorials (Start Here) How-To Guides Discussions Reference Guides Technical reference: API Reference Architectural Decision Records Changelog This documentation structure is based on Daniele Procida's excellent article on the Divio blog.","title":"Contents"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 Added \u00b6 Added primitive generators: Constant , Integer , HashDigest . Changed \u00b6 Fixed \u00b6 Removed \u00b6 0.1.0 \u00b6 Added \u00b6 Initial project skeleton.","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"Unreleased"},{"location":"CHANGELOG/#added","text":"Added primitive generators: Constant , Integer , HashDigest .","title":"Added"},{"location":"CHANGELOG/#changed","text":"","title":"Changed"},{"location":"CHANGELOG/#fixed","text":"","title":"Fixed"},{"location":"CHANGELOG/#removed","text":"","title":"Removed"},{"location":"CHANGELOG/#010","text":"","title":"0.1.0"},{"location":"CHANGELOG/#added_1","text":"Initial project skeleton.","title":"Added"},{"location":"attributions/","text":"Attributions The tohu logo is \"Chaos\" , created by Anna Sophie from the Noun Project (licensed under CC BY 3.0 )","title":"Attributions"},{"location":"ADRs/","text":"What are ADRs? Architectural Decision Records (ADR's) provide a lightweight format for documenting the reasons why certain architectural or technical decisions were taken, and more importantly the context which led to these decisions. This allows to revisit these decisions later on, in case the context changes or more information becomes available. See Michael Nygard's blog post for more details on ADR's. Despite the name \"architectural decision records\", where appropriate it is also encouraged to document technological decisions (for example which Javascript framework to use for a web frontend) or \"cultural\" decisions. ADR's should be placed in sepearate files that are numbered sequentially (e.g. 0001-some-useful-description.md ). The contents should follow this template : Title: short present tense imperative phrase, less than 50 characters, like a git commit message. Date: when was this issue discussed (to give approximate temporal context) Status: proposed, accepted, rejected, deprecated, superseded, etc. Context: what is the issue that we're seeing that is motivating this decision or change. This section describes the forces at play, including technological, political, social, and project local. These forces are probably in tension, and should be called out as such. The language in this section is value-neutral. It is simply describing facts. Decision: what is the change that we're actually proposing or doing (describes our response to these forces) Consequences: what becomes easier or more difficult to do because of this change. All consequences should be listed here, not just the \"positive\" ones. A particular decision may have positive, negative, and neutral consequences, but all of them affect the team and project in the future.","title":"What are ADRs?"},{"location":"discussions/","text":"Introduction This section contains discussions . A discussion: is understanding-oriented explains provides background and context (See here for context and more information.)","title":"Introduction"},{"location":"discussions/how_is_this_different_from_xyz/","text":"How is tohu different from XYZ? TODO: Write me!","title":"How is tohu different from XYZ?"},{"location":"how_to_guides/","text":"Introduction This section contains how-to guides . A how-to guide: is goal-oriented shows how to solve a specific problem is a series of steps (See here for context and more information.)","title":"Introduction"},{"location":"how_to_guides/installation/","text":"Installing tohu You can install the latest release by running: $ pip install -U tohu You can also grab the latest development version directly from GitHub: $ pip install git+https://github.com/maxalbert/tohu","title":"Installing tohu"},{"location":"how_to_guides/running_the_tests/","text":"Running the tests $ poetry run pytest Example output: ============================= test session starts ============================== platform linux -- Python 3.8.1, pytest-3.10.1, py-1.8.0, pluggy-0.13.0 rootdir: /path/to/code/tohu, inifile: collected 1 item tests/test_tohu.py . [100%] =========================== 1 passed in 0.11 seconds ===========================","title":"Running the tests"},{"location":"how_to_guides/setting_up_dev_environment/","text":"Setting up a development environment tohu uses poetry for dependency management, so make sure you have it installed . Next, install the necessary dependencies for tohu . We specify the --extras options to install the complete set of packages for a full development environment. $ poetry install --extras \"develop testing docs deploy\"","title":"Setting up a development environment"},{"location":"reference_guides/","text":"Introduction This section contains reference guides . A reference guide: is information-oriented describes the machinery is accurate and complete (See here for context and more information.)","title":"Introduction"},{"location":"reference_guides/primitive_generators/","text":"Primitive generators # Import the primitive generator and helper function used below. from tohu.primitive_generators import * from tohu.utils import print_generated_sequence This section demonstrates the primitive generators available in tohu . Constant Boolean Integer HashDigest FakerGenerator Constant \u00b6 The Constant generator produces a sequence whose items all have the same fixed value. g = Constant ( \"quux\" ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: quux, quux, quux, quux, quux, quux, quux, quux, quux, quux Boolean \u00b6 The Boolean generator produces a sequence of True / False values, where True is returned with probability p . g = Boolean ( p = 0.3 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: True, False, False, False, False, True, False, False, False, False Integer \u00b6 The Integer generator produces random integers in the range between low and high (both inclusive). g = Integer ( low = 100 , high = 200 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 115, 139, 164, 183, 194, 130, 145, 152, 125, 132 HashDigest \u00b6 The HashDigest generator produces a sequence of hex strings representing hash digest values. By default, it produces hex strings of the specified length. g = HashDigest ( length = 6 ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 4B4D02 9097BC EC6DF8 B3E6CA EE19B1 Instead of hex strings, the generator can produce the equivalent byte strings by setting as_bytes=True . g = HashDigest ( length = 3 , as_bytes = True ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: b'KM\\x02' b'\\x90\\x97\\xbc' b'\\xecm\\xf8' b'\\xb3\\xe6\\xca' b'\\xee\\x19\\xb1' The lowercase keyword can be used to produce hex strings with lowercase characters (note this has no effect when as_bytes=True ). g = HashDigest ( length = 8 , lowercase = True ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 4b4d0235, 9097bc5e, ec6df8fc, b3e6caf3, ee19b1d3, 9fc0b7fd, 6f07a116, ac591849, 91fa77c5, f863c55d FakerGenerator \u00b6 FakerGenerator allows to produce elements using any of the providers provided by the Faker package. The provider is specified using the method argument. Examples: g = FakerGenerator ( method = \"name\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: Eric Benton Heather Harris Thomas Obrien Amy Cook Kenneth Robles g = FakerGenerator ( method = \"address\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 356 Richard Valleys Madelineton, ME 76205 25835 Deborah Creek Rhondaport, WI 54356 9826 Sullivan Brook Apt. 610 Duncanfort, PA 04949 6408 Gabrielle Stream East Margaret, KY 58692 51904 Garcia Walks Port Philip, RI 10457","title":"Primitive generators"},{"location":"reference_guides/primitive_generators/#constant","text":"The Constant generator produces a sequence whose items all have the same fixed value. g = Constant ( \"quux\" ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: quux, quux, quux, quux, quux, quux, quux, quux, quux, quux","title":"Constant"},{"location":"reference_guides/primitive_generators/#boolean","text":"The Boolean generator produces a sequence of True / False values, where True is returned with probability p . g = Boolean ( p = 0.3 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: True, False, False, False, False, True, False, False, False, False","title":"Boolean"},{"location":"reference_guides/primitive_generators/#integer","text":"The Integer generator produces random integers in the range between low and high (both inclusive). g = Integer ( low = 100 , high = 200 ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 115, 139, 164, 183, 194, 130, 145, 152, 125, 132","title":"Integer"},{"location":"reference_guides/primitive_generators/#hashdigest","text":"The HashDigest generator produces a sequence of hex strings representing hash digest values. By default, it produces hex strings of the specified length. g = HashDigest ( length = 6 ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 4B4D02 9097BC EC6DF8 B3E6CA EE19B1 Instead of hex strings, the generator can produce the equivalent byte strings by setting as_bytes=True . g = HashDigest ( length = 3 , as_bytes = True ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: b'KM\\x02' b'\\x90\\x97\\xbc' b'\\xecm\\xf8' b'\\xb3\\xe6\\xca' b'\\xee\\x19\\xb1' The lowercase keyword can be used to produce hex strings with lowercase characters (note this has no effect when as_bytes=True ). g = HashDigest ( length = 8 , lowercase = True ) print_generated_sequence ( g , 10 , seed = 99999 ) Generated sequence: 4b4d0235, 9097bc5e, ec6df8fc, b3e6caf3, ee19b1d3, 9fc0b7fd, 6f07a116, ac591849, 91fa77c5, f863c55d","title":"HashDigest"},{"location":"reference_guides/primitive_generators/#fakergenerator","text":"FakerGenerator allows to produce elements using any of the providers provided by the Faker package. The provider is specified using the method argument. Examples: g = FakerGenerator ( method = \"name\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: Eric Benton Heather Harris Thomas Obrien Amy Cook Kenneth Robles g = FakerGenerator ( method = \"address\" ) print_generated_sequence ( g , 5 , seed = 99999 , sep = \" \\n \" ) Generated sequence: 356 Richard Valleys Madelineton, ME 76205 25835 Deborah Creek Rhondaport, WI 54356 9826 Sullivan Brook Apt. 610 Duncanfort, PA 04949 6408 Gabrielle Stream East Margaret, KY 58692 51904 Garcia Walks Port Philip, RI 10457","title":"FakerGenerator"},{"location":"reference_guides/internals/debugging_support/","text":"Debugging Support In Tohu from tohu import Integer , HashDigest , CustomGenerator Every tohu generator instance has an internal tohu_id . g1 = Integer ( low = 100 , high = 200 ) g2 = HashDigest ( length = 8 ) # NBVAL_IGNORE_OUTPUT print ( g1 . tohu_id ) print ( g2 . tohu_id ) 17bf26 bfc231 This is also included when generators are printed. print ( g1 ) print ( g2 ) <Integer (id=17bf26)> <HashDigest (id=bfc231)> For debugging purposes, it is possible to assign an explicit name, which can make it easier to identify tohu generators when working out dependencies between them. g1 . set_tohu_name ( \"g1\" ) <g1: Integer (id=17bf26)> A common way to do this is when defining custom generators, like this: class QuuxGenerator ( CustomGenerator ): aa = Integer ( low = 100 , high = 200 ) bb = HashDigest ( length = 8 ) . set_tohu_name ( \"bb\" ) g = QuuxGenerator () print ( g ) print ( g . aa ) print ( g . bb ) <QuuxGenerator (id=cbdd27)> <Integer (id=8f15b3)> <bb: HashDigest (id=9eeeef)>","title":"Debugging Support In Tohu"},{"location":"reference_guides/internals/seed_generator/","text":"SeedGenerator The SeedGenerator is is used internally by tohu to produce seeds with which to reset other generators (for example, the constituent generators in a CustomGenerator instance). It produces integers in the range from 0 to 2^32-1, as illustrated below. from tohu.base import SeedGenerator seed_generator = SeedGenerator () seed_generator . reset ( 12345 ) for _ in range ( 10 ): print ( next ( seed_generator )) 831769172 2430986565 694443915 1859447115 2376066489 2164385946 636282949 3087940365 1466990855 101022850","title":"SeedGenerator"},{"location":"reference_guides/internals/tohu_items_class/","text":"Tohu Items make_tohu_items_class() derive_tohu_items_class_name() make_tohu_items_class() \u00b6 TODO: add a short overview of what this section is about. from tohu.tohu_items_class import make_tohu_items_class quux_cls = make_tohu_items_class ( \"Quux\" , [ \"aa\" , \"bb\" , \"cc\" ]) print ( quux_cls ) <class 'tohu.tohu_items_class.Quux'> This can then be used to create individual items with these attributes. quux1 = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) quux2 = quux_cls ( aa = 20 , bb = \"bar\" , cc = False ) print ( quux1 ) print ( quux2 ) Quux(aa=10, bb='foo', cc=True) Quux(aa=20, bb='bar', cc=False) This is used internally by custom generators when producing items. These items can be compared, too: quux1_new = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) Items compare equal if they contain the same values (even if they are technically different objects). assert quux1 is quux1 assert quux1 == quux1 assert quux1 is not quux1_new assert quux1 == quux1_new assert quux1 != quux2 For convenience, tohu items can also directly be compared with dictionaries or tuples. assert quux1 == ( 10 , \"foo\" , True ) assert quux1 == { \"aa\" : 10 , \"bb\" : \"foo\" , \"cc\" : True } assert quux1 != ( 20 , \"bar\" , False ) We can retrieve the field names of an item using the field_names attribute. quux1 . field_names ['aa', 'bb', 'cc'] And we can convert it to a dict or a tuple using convenience helper methods. quux1 . as_dict () {'aa': 10, 'bb': 'foo', 'cc': True} quux1 . as_tuple () (10, 'foo', True) derive_tohu_items_class_name() \u00b6 from tohu.tohu_items_class import derive_tohu_items_class_name The helper function derive_tohu_items_class_name takes the name of a custom generator class as argument and simply strips the ...Generator suffix. derive_tohu_items_class_name ( \"QuuxGenerator\" ) 'Quux' derive_tohu_items_class_name ( \"FooBarGenerator\" ) 'FooBar' If the class name doesn't end with Generator , it raises an error. #derive_tohu_items_class_name(\"Quux\")","title":"Tohu Items"},{"location":"reference_guides/internals/tohu_items_class/#make_tohu_items_class","text":"TODO: add a short overview of what this section is about. from tohu.tohu_items_class import make_tohu_items_class quux_cls = make_tohu_items_class ( \"Quux\" , [ \"aa\" , \"bb\" , \"cc\" ]) print ( quux_cls ) <class 'tohu.tohu_items_class.Quux'> This can then be used to create individual items with these attributes. quux1 = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) quux2 = quux_cls ( aa = 20 , bb = \"bar\" , cc = False ) print ( quux1 ) print ( quux2 ) Quux(aa=10, bb='foo', cc=True) Quux(aa=20, bb='bar', cc=False) This is used internally by custom generators when producing items. These items can be compared, too: quux1_new = quux_cls ( aa = 10 , bb = \"foo\" , cc = True ) Items compare equal if they contain the same values (even if they are technically different objects). assert quux1 is quux1 assert quux1 == quux1 assert quux1 is not quux1_new assert quux1 == quux1_new assert quux1 != quux2 For convenience, tohu items can also directly be compared with dictionaries or tuples. assert quux1 == ( 10 , \"foo\" , True ) assert quux1 == { \"aa\" : 10 , \"bb\" : \"foo\" , \"cc\" : True } assert quux1 != ( 20 , \"bar\" , False ) We can retrieve the field names of an item using the field_names attribute. quux1 . field_names ['aa', 'bb', 'cc'] And we can convert it to a dict or a tuple using convenience helper methods. quux1 . as_dict () {'aa': 10, 'bb': 'foo', 'cc': True} quux1 . as_tuple () (10, 'foo', True)","title":"make_tohu_items_class()"},{"location":"reference_guides/internals/tohu_items_class/#derive_tohu_items_class_name","text":"from tohu.tohu_items_class import derive_tohu_items_class_name The helper function derive_tohu_items_class_name takes the name of a custom generator class as argument and simply strips the ...Generator suffix. derive_tohu_items_class_name ( \"QuuxGenerator\" ) 'Quux' derive_tohu_items_class_name ( \"FooBarGenerator\" ) 'FooBar' If the class name doesn't end with Generator , it raises an error. #derive_tohu_items_class_name(\"Quux\")","title":"derive_tohu_items_class_name()"},{"location":"tutorials/","text":"Introduction This section contains Tutorials . A tutorial: is learning-oriented allows the newcomer to get started is a lesson (See here for context and more information.)","title":"Introduction"},{"location":"tutorials/custom_generators/","text":"Custom Generators This section introduces \"custom generators\", which allow to combine individual generators into a single new entity. Introduction Example: Generating \"Person\" Records Introduction \u00b6 Primitive generators are nice, but on their own they are barely more useful than existing random number generators such as Python's built-in random module, numpy 's (random)[ https://docs.scipy.org/doc/numpy/reference/random/index.html ] module or the faker package. (Perhaps the most useful aspect about primitive generators on their own is that they present a consistent interface for generating random items of different types, but this alone rarely justifies the existence of a package like tohu .) The real power of tohu lies in how it allows to easily combine other generators into \"compound\" generators. In tohu these are called CustomGenerators (TODO: should this name be changed to CompoundGenerator ?). Example: Generating \"Person\" Records \u00b6 Imagine you want to create synthetic data that represents information about a person. For each person you may want to create a name, an age, and a job decription. As we learned before in the section about primitive generators, we can generate these kinds of data separately, but how do we combine them into proper \"Person\" records? The answer is, we use a CustomGenerator . Let's look at an example. As before, we present the full example first and then analyse it in more detail. from tohu import FakerGenerator , Integer , CustomGenerator class PersonGenerator ( CustomGenerator ): name = FakerGenerator ( method = \"name\" ) age = Integer ( 0 , 99 ) job = FakerGenerator ( method = \"job\" ) g = PersonGenerator () g . generate_as_list ( num = 5 , seed = 12345 ) [Person(name='Jonathan Hernandez', age=55, job='Web designer'), Person(name='Cheryl Stevens', age=24, job='Prison officer'), Person(name='Manuel Mclean', age=17, job='Fine artist'), Person(name='Paul Malone', age=70, job='Horticulturist, commercial'), Person(name='Jason Dickson', age=18, job='Journalist, broadcasting')]","title":"Custom Generators"},{"location":"tutorials/custom_generators/#introduction","text":"Primitive generators are nice, but on their own they are barely more useful than existing random number generators such as Python's built-in random module, numpy 's (random)[ https://docs.scipy.org/doc/numpy/reference/random/index.html ] module or the faker package. (Perhaps the most useful aspect about primitive generators on their own is that they present a consistent interface for generating random items of different types, but this alone rarely justifies the existence of a package like tohu .) The real power of tohu lies in how it allows to easily combine other generators into \"compound\" generators. In tohu these are called CustomGenerators (TODO: should this name be changed to CompoundGenerator ?).","title":"Introduction"},{"location":"tutorials/custom_generators/#example-generating-person-records","text":"Imagine you want to create synthetic data that represents information about a person. For each person you may want to create a name, an age, and a job decription. As we learned before in the section about primitive generators, we can generate these kinds of data separately, but how do we combine them into proper \"Person\" records? The answer is, we use a CustomGenerator . Let's look at an example. As before, we present the full example first and then analyse it in more detail. from tohu import FakerGenerator , Integer , CustomGenerator class PersonGenerator ( CustomGenerator ): name = FakerGenerator ( method = \"name\" ) age = Integer ( 0 , 99 ) job = FakerGenerator ( method = \"job\" ) g = PersonGenerator () g . generate_as_list ( num = 5 , seed = 12345 ) [Person(name='Jonathan Hernandez', age=55, job='Web designer'), Person(name='Cheryl Stevens', age=24, job='Prison officer'), Person(name='Manuel Mclean', age=17, job='Fine artist'), Person(name='Paul Malone', age=70, job='Horticulturist, commercial'), Person(name='Jason Dickson', age=18, job='Journalist, broadcasting')]","title":"Example: Generating \"Person\" Records"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/","text":"Primitive Generators - The Basic Building Blocks Introduction First example: using Integer to produce random integers Analysing the example Creating the Integer generator Resetting the generator Producing individual random values Producing a sequence of random values Second example: producing random HashDigest values Summary And Next Steps Introduction \u00b6 The most fundamental building blocks of tohu are the so-called \"primitive\" generators. A primitive generator is simply a random generator which knows how to produce values of a specific \"type\" (in a slightly loose sense of the word). For example, there are primitive generators which produce random integers, random boolean values, random names, etc. (see here for a full list). The reason they are called \"primitive\" is because they do not depend on any other generators in tohu , and they can be combined into more complex generators (see subsequent sections). This section illustrates how to create and use primitive generators directly. Note that in practical use you will rarely need or want to create them manually as we do here - typically, they will be created as part of a CustomGenerator (TODO: see section [...]). However, it is useful to get a feel for how they work under the hood, so let's look at an example. First example: using Integer to produce random integers \u00b6 For our first example, let's use the Integer generator, which produces random integers in a given range. Here is the full code snippet and its output (we will look at this line by line in the next section). from tohu.primitive_generators import Integer # Create an instance of an Integer generator g = Integer ( 100 , 200 ) g . reset ( seed = 12345 ) # Produce a single value print ( next ( g )) # Produce a few more values manually for _ in range ( 3 ): print ( next ( g )) # Produce a sequence of values #g.generate(num=10, seed=12345) 153 193 101 138 Analysing the example \u00b6 Creating the Integer generator \u00b6 First we create an Integer generator that will produce values between 100 and 200. g = Integer ( 100 , 200 ) Resetting the generator \u00b6 Before we actually make it produce any values, we first reset the generator. The purpose of this is to initialize the internal (pseudo-)random number generator so that the output is reproducible. The seed argument which we pass to the reset method can have any value. As long as you pass the same seed the generator will produce the same sequence of output values, which ensures reproducibility. g . reset ( seed = 12345 ) <Integer (id=1273e4)> Producing individual random values \u00b6 Now that we have a primitive generator in a well-defined state, how can we produce values using this generator? One way of doing this is to call next() on it, which will ask g to produce a single new value for us. print ( next ( g )) 153 We can do this as many times as we want, and each time g will produce a new random integer in the range [100, 200] . Let's get five more. for _ in range ( 5 ): print ( next ( g )) 193 101 138 147 124 Producing a sequence of random values \u00b6 While this works ok, it quickly becomes cumbersome if we need a lot of values. A more convenient way is to call the generate_as_list method. We can pass the number of elements we want, as well as (optionally) a seed. If the seed is given, this internally calls reset , which ensures that the returned sequence is reproducible (see above). g . generate_as_list ( num = 15 , seed = 99999 ) [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] This is much more convenient, and often the right choice. However, if num is very big then it may be expensive (both in terms of time and memory) to generate all elements at once and store them in a huge list. An alternative would be to call generate_as_stream instead. The result is a Python generator object, and we can iterate over this to obtain the elements sequentially (but this happens in a \"lazy\" fashion, so it is much more time and memory efficient. result = g . generate_as_stream ( num = 15 , seed = 99999 ) print ( result ) <generator object TohuBaseGenerator.generate_as_stream at 0x10f2eab30> [ x for x in result ] [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] Beware that as usual with Python generator objects, once you have iterated over the result it will be exhausted so you can't iterate over it a second time, or else you won't get any elements: [ x for x in result ] [] You should therefore carefully choose which method of generating items is best for your use case. For interactive exploration it is often more convenient to generate lists because they don't need as careful treatment, but if you need to be careful with performance or memory efficiency you can use the stream method instead. Second example: producing random HashDigest values \u00b6 Let's look at another example using a different primitive generator. We choose HashDigest . This produces random strings that look like hash values. The example follows the same pattern as above: Create an instance of the HashDigest generator. Reset it to ensure the output is reproducible. Produce a sequence of elements by calling the generate method. from tohu.primitive_generators import HashDigest g = HashDigest ( length = 8 , lowercase = True ) g . reset ( seed = 99999 ) for _ in range ( 5 ): print ( next ( g )) 4b4d0235 9097bc5e ec6df8fc b3e6caf3 ee19b1d3 g . generate_as_list ( num = 5 , seed = 99999 ) ['4b4d0235', '9097bc5e', 'ec6df8fc', 'b3e6caf3', 'ee19b1d3'] Summary And Next Steps \u00b6 TODO","title":"Primitive Generators - The Basic Building Blocks"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#introduction","text":"The most fundamental building blocks of tohu are the so-called \"primitive\" generators. A primitive generator is simply a random generator which knows how to produce values of a specific \"type\" (in a slightly loose sense of the word). For example, there are primitive generators which produce random integers, random boolean values, random names, etc. (see here for a full list). The reason they are called \"primitive\" is because they do not depend on any other generators in tohu , and they can be combined into more complex generators (see subsequent sections). This section illustrates how to create and use primitive generators directly. Note that in practical use you will rarely need or want to create them manually as we do here - typically, they will be created as part of a CustomGenerator (TODO: see section [...]). However, it is useful to get a feel for how they work under the hood, so let's look at an example.","title":"Introduction"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#first-example-using-integer-to-produce-random-integers","text":"For our first example, let's use the Integer generator, which produces random integers in a given range. Here is the full code snippet and its output (we will look at this line by line in the next section). from tohu.primitive_generators import Integer # Create an instance of an Integer generator g = Integer ( 100 , 200 ) g . reset ( seed = 12345 ) # Produce a single value print ( next ( g )) # Produce a few more values manually for _ in range ( 3 ): print ( next ( g )) # Produce a sequence of values #g.generate(num=10, seed=12345) 153 193 101 138","title":"First example: using Integer to produce random integers"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#analysing-the-example","text":"","title":"Analysing the example"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#creating-the-integer-generator","text":"First we create an Integer generator that will produce values between 100 and 200. g = Integer ( 100 , 200 )","title":"Creating the Integer generator"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#resetting-the-generator","text":"Before we actually make it produce any values, we first reset the generator. The purpose of this is to initialize the internal (pseudo-)random number generator so that the output is reproducible. The seed argument which we pass to the reset method can have any value. As long as you pass the same seed the generator will produce the same sequence of output values, which ensures reproducibility. g . reset ( seed = 12345 ) <Integer (id=1273e4)>","title":"Resetting the generator"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#producing-individual-random-values","text":"Now that we have a primitive generator in a well-defined state, how can we produce values using this generator? One way of doing this is to call next() on it, which will ask g to produce a single new value for us. print ( next ( g )) 153 We can do this as many times as we want, and each time g will produce a new random integer in the range [100, 200] . Let's get five more. for _ in range ( 5 ): print ( next ( g )) 193 101 138 147 124","title":"Producing individual random values"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#producing-a-sequence-of-random-values","text":"While this works ok, it quickly becomes cumbersome if we need a lot of values. A more convenient way is to call the generate_as_list method. We can pass the number of elements we want, as well as (optionally) a seed. If the seed is given, this internally calls reset , which ensures that the returned sequence is reproducible (see above). g . generate_as_list ( num = 15 , seed = 99999 ) [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] This is much more convenient, and often the right choice. However, if num is very big then it may be expensive (both in terms of time and memory) to generate all elements at once and store them in a huge list. An alternative would be to call generate_as_stream instead. The result is a Python generator object, and we can iterate over this to obtain the elements sequentially (but this happens in a \"lazy\" fashion, so it is much more time and memory efficient. result = g . generate_as_stream ( num = 15 , seed = 99999 ) print ( result ) <generator object TohuBaseGenerator.generate_as_stream at 0x10f2eab30> [ x for x in result ] [115, 139, 164, 183, 194, 130, 145, 152, 125, 132, 151, 192, 177, 177, 166] Beware that as usual with Python generator objects, once you have iterated over the result it will be exhausted so you can't iterate over it a second time, or else you won't get any elements: [ x for x in result ] [] You should therefore carefully choose which method of generating items is best for your use case. For interactive exploration it is often more convenient to generate lists because they don't need as careful treatment, but if you need to be careful with performance or memory efficiency you can use the stream method instead.","title":"Producing a sequence of random values"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#second-example-producing-random-hashdigest-values","text":"Let's look at another example using a different primitive generator. We choose HashDigest . This produces random strings that look like hash values. The example follows the same pattern as above: Create an instance of the HashDigest generator. Reset it to ensure the output is reproducible. Produce a sequence of elements by calling the generate method. from tohu.primitive_generators import HashDigest g = HashDigest ( length = 8 , lowercase = True ) g . reset ( seed = 99999 ) for _ in range ( 5 ): print ( next ( g )) 4b4d0235 9097bc5e ec6df8fc b3e6caf3 ee19b1d3 g . generate_as_list ( num = 5 , seed = 99999 ) ['4b4d0235', '9097bc5e', 'ec6df8fc', 'b3e6caf3', 'ee19b1d3']","title":"Second example: producing random HashDigest values"},{"location":"tutorials/the_basic_building_blocks_primitive_generators/#summary-and-next-steps","text":"TODO","title":"Summary And Next Steps"}]}